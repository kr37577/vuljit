#!/usr/bin/env python3
"""
Summarize OSS-Fuzz vulnerability reports for C/C++ projects.

This script joins the project metadata produced by oss_fuzz_project_info.py with
the vulnerability CSV generated by ossfuzz_vulnerability_issue_report_extraction.py
and reports how many vulnerability records exist per project.
"""

from __future__ import annotations

import argparse
import csv
import os
from collections import Counter, defaultdict
from pathlib import Path
from typing import Dict, Iterable, List

REPO_ROOT = Path(__file__).resolve().parents[2]
DEFAULT_METADATA = REPO_ROOT / "datasets" / "derived_artifacts" / "oss_fuzz_metadata" / "oss_fuzz_project_metadata.csv"
DEFAULT_VULNS = REPO_ROOT / "datasets" / "derived_artifacts" / "vulnerability_reports" / "oss_fuzz_vulnerabilities.csv"
DEFAULT_OUT = REPO_ROOT / "datasets" / "derived_artifacts" / "oss_fuzz_metadata" / "c_cpp_vulnerability_summary.csv"


def normalize_repo(url: str | None) -> str:
    """Normalize repository URLs for matching."""
    if not url:
        return ""
    norm = url.strip()
    if not norm:
        return ""
    norm = norm.rstrip("/")
    if norm.lower().endswith(".git"):
        norm = norm[:-4]
    return norm.lower()


def load_metadata(path: Path) -> tuple[Dict[str, List[Dict[str, str]]], Dict[str, Dict[str, str]]]:
    """Load metadata CSV and return mapping of normalized repo -> project entries."""
    repo_to_projects: Dict[str, List[Dict[str, str]]] = defaultdict(list)
    project_index: Dict[str, Dict[str, str]] = {}
    seen_pairs = set()
    with path.open(newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            language = (row.get("language") or "").strip().lower()
            if language not in {"c", "c++"}:
                continue
            project = (row.get("project") or "").strip()
            repo = normalize_repo(row.get("main_repo"))
            if not project or not repo:
                continue
            entry = {
                "project": project,
                "language": language,
                "main_repo": row.get("main_repo", ""),
            }
            key = (repo, project)
            if key in seen_pairs:
                continue
            seen_pairs.add(key)
            repo_to_projects[repo].append(entry)
            project_index[project] = entry
    return repo_to_projects, project_index


def summarize_vulnerabilities(
    vuln_path: Path, repo_to_projects: Dict[str, List[Dict[str, str]]]
) -> tuple[Counter, Dict[str, List[Dict[str, str]]], int]:
    """Return counts per project, detail mapping, and matched row count."""
    project_counts: Counter = Counter()
    project_details: Dict[str, List[Dict[str, str]]] = defaultdict(list)
    matched_rows = 0
    with vuln_path.open(newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            repo = normalize_repo(row.get("repo"))
            if not repo or repo not in repo_to_projects:
                continue
            matched_rows += 1
            for entry in repo_to_projects[repo]:
                project = entry["project"]
                project_counts[project] += 1
                project_details[project].append(
                    {
                        "monorail_id": row.get("monorail_id", ""),
                        "OSV_id": row.get("OSV_id", ""),
                        "severity": row.get("severity", ""),
                        "repo": row.get("repo", ""),
                    }
                )
    return project_counts, project_details, matched_rows


def write_summary(
    out_path: Path,
    counts: Counter,
    details: Dict[str, List[Dict[str, str]]],
    project_index: Dict[str, Dict[str, str]],
) -> None:
    """Write per-project summary CSV."""
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with out_path.open("w", newline="", encoding="utf-8") as f:
        fieldnames = ["project", "language", "main_repo", "vulnerability_count"]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for project, count in counts.most_common():
            entry = project_index.get(project, {})

            writer.writerow(
                {
                    "project": project,
                    "language": entry.get("language", ""),
                    "main_repo": entry.get("main_repo", ""),
                    "vulnerability_count": count,
                }
            )


def main(argv: Iterable[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        description="Summarize OSS-Fuzz vulnerability records for C/C++ projects."
    )
    parser.add_argument(
        "--metadata",
        default=str(DEFAULT_METADATA),
        help="Path to oss_fuzz_project_metadata.csv (default: %(default)s)",
    )
    parser.add_argument(
        "--vulnerabilities",
        default=str(DEFAULT_VULNS),
        help="Path to oss_fuzz_vulnerabilities.csv (default: %(default)s)",
    )
    parser.add_argument(
        "--out",
        default=str(DEFAULT_OUT),
        help="Where to write summary CSV (default: %(default)s)",
    )
    parser.add_argument(
        "--include-details",
        action="store_true",
        help="Print matched vulnerability IDs for inspection.",
    )
    args = parser.parse_args(argv)

    metadata_path = Path(args.metadata)
    vuln_path = Path(args.vulnerabilities)

    if not metadata_path.is_file():
        parser.error(f"metadata file not found: {metadata_path}")
    if not vuln_path.is_file():
        parser.error(f"vulnerabilities file not found: {vuln_path}")

    repo_to_projects, project_index = load_metadata(metadata_path)
    counts, details, matched_rows = summarize_vulnerabilities(vuln_path, repo_to_projects)

    total_projects = len(project_index)
    print(f"Metadata projects (C/C++): {total_projects}")
    print(f"Matched vulnerability rows: {matched_rows}")
    print(f"Unique projects with vulnerabilities: {len(counts)}")

    top_n = min(10, len(counts))
    if top_n:
        print("Top projects by vulnerability count:")
        for project, count in counts.most_common(top_n):
            print(f"  {project}: {count}")

    if args.include_details:
        for project, items in details.items():
            print(f"\n{project} ({len(items)} vulns)")
            for item in items[:10]:
                print(
                    f"  monorail={item['monorail_id']} OSV={item['OSV_id']} severity={item['severity']}"
                )
            if len(items) > 10:
                print(f"  ... {len(items) - 10} more")

    out_path = Path(args.out)
    write_summary(out_path, counts, details, project_index)
    print(f"Summary written to {out_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
